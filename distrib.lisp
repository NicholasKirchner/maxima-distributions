(defprop $delta %delta verb)
(defprop $delta %delta alias)
(defprop %delta $delta noun)
(defprop %delta $delta reversealias)

(defprop %delta simp-delta operators)

(defun $delta (arg)
   (simplify (list '(%delta) arg)))

(defun simp-delta (expr z simpflag)
  (oneargcheck expr)
  (setq z (simpcheck (cadr expr) simpflag))
  (cond ((numberp z)
         (cond ((zerop1 z)
                (merror (intl:gettext "delta: undefined: evaluate delta functional at zero.")))
               (t 0)))
        ((atom z)
         (eqtest (list '(%delta) z) expr))
        ((and (eq (caar z) 'mtimes) (numberp (cadr z)) (not (zerop1 (cadr z))))
         (simplify (list '(mtimes)
                         (list '(mexpt)
                               (list '(mabs) (cadr z))
                               -1)
                         (list '(%delta) (append (list '(mtimes))
                                                   (cddr z))))))
        (t
         (eqtest (list '(%delta) z) expr))))

(defprop $doublet %doublet verb)
(defprop $doublet %doublet alias)
(defprop %doublet $doublet noun)
(defprop %doublet $doublet reversealias)

(defprop %doublet simp-doublet operators)

(defun $doublet (arg)
  (simplify (list '(%doublet) arg)))

(defun simp-doublet (expr z simpflag)
  (oneargcheck expr)
  (setq z (simpcheck (cadr expr) simpflag))
  (cond ((numberp z)
         (cond ((zerop1 z)
                (merror (intl:gettext "doublet: undefined: evaluate doublet functional at zero.")))
               (t 0)))
        ((atom z)
         (eqtest (list '(%doublet) z) expr))
        ((and (eq (caar z) 'mtimes) (numberp (cadr z)) (not (zerop1 (cadr z))))
         (simplify (list '(mtimes)
                         (list '(mexpt)
                               (list '(mtimes) (cadr z) (list '(mabs) (cadr z)))
                               -1)
                         (list '(%doublet) (append (list '(mtimes))
                                                   (cddr z))))))
        (t
         (eqtest (list '(%doublet) z) expr))))

(defprop $heaviside %heaviside verb)
(defprop $heaviside %heaviside alias)
(defprop %heaviside $heaviside noun)
(defprop %heaviside $heaviside reversealias)

(defprop %heaviside simp-heaviside operators)

(defun $heaviside (arg)
  (simplify (list '(%heaviside) arg)))

(defun simp-heaviside (expr z simpflag)
  (oneargcheck expr)
  (setq z (simpcheck (cadr expr) simpflag))
  (cond ((numberp z)
         (cond ((< z 0) 0)
               ((> z 0) 1)
               (t (rat 1 2))))
        ((zerop1 z) (rat 1 2))
        ((atom z)
         (eqtest (list '(%heaviside) z) expr))
        ((and (eq (caar z) 'mtimes) (numberp (cadr z)) (not (zerop1 (cadr z))))
         (simplify (list '(%heaviside) (append (list '(mtimes)) (cddr z)))))
        (t
         (eqtest (list '(%heaviside) z) expr))))

(defun distribint (exp var &rest y)
  (cond ((eq (list-length y) 0)
         ())
        ((eq (list-length y) 2)
         ())
        (t
         (merror (intl:gettext "Internal error with distribint function: invalid number of arguments"))
